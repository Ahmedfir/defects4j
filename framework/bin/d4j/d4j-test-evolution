#-------------------------------------------------------------------------------
# Copyright (c) 2014-2018 Ren√© Just, Darioush Jalali, and Defects4J contributors.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#-------------------------------------------------------------------------------

=pod

=head1 NAME

d4j-test-evolution -- evolve source code commit by commit and extract runtime
information of a developer-written or automatically generated test suite.

=head1 SYNOPSIS

  d4j-test-evolution [-w work_dir] [-b] [-r | -s test_suite]

=head1 DESCRIPTION

Performs a test evolution analysis by running a provided test suite (i.e., the
developer-written test suite or an automatically generated test suite) on all
past or future commits beginning with the program version/commit for which the
test suite was generated. The analysis stops as soon as D4J is not able to go
any further in the repository history or if the project under test / test suite
does not compile.

=head1 OPTIONS

=over 4

=item -w F<work_dir>

The working directory of the checked-out project version (optional). Default is
the current directory.

=item -c

Perform test evolution analysis on future commits (optional). By default test
evolution analysis is performed on past commits.

=item -r

Only execute relevant developer-written tests (optional). By default all
developer-written tests of the checked-out project version are executed.

=item -s F<test_suite>

The archive file name of an external test suite (optional). The default test
suite is the developer-written test suite of the checked-out project version.
See L<Test suites|/"Test suites">.

=back

=head1 Test Suites

An external test suite has to be provided as an archive that contains the test
sources. Format of the archive file name:

F<C<project_id>-C<version_id>-C<test_suite_src>.C<test_id>.tar.bz2>

Examples:

=over 4

=item * F<Lang-11f-randoop.1.tar.bz2>

=item * F<Lang-12b-evosuite-weakmutation.1.tar.bz2>

=item * F<Lang-12f-evosuite-branch.1.tar.bz2>

=back

=cut

use warnings;
use strict;

use Constants;
use Utils;
use Project;
use Getopt::Std;
use Pod::Usage;

#
# Process arguments and issue usage message if necessary.
#
my %cmd_opts;
getopts('w:c:rs:', \%cmd_opts) or pod2usage( { -verbose => 1, -input => __FILE__} );

my $WORK_DIR            = Utils::get_abs_path($cmd_opts{w} // ".");
my $FUTURE_COMMITS      = defined $cmd_opts{c} ? 1 : 0;
my $REL_TESTS           = defined $cmd_opts{r} ? 1 : 0;
my $TEST_SUITE_ARCHIVE  = $cmd_opts{s};
if (defined $TEST_SUITE_ARCHIVE && $REL_TESTS == 1) {
    pod2usage( { -verbose => 1, -input => __FILE__} );
}

my $config = Utils::read_config_file("$WORK_DIR/$CONFIG");
unless(defined $config) {
    print(STDERR "$WORK_DIR is not a valid working directory!\n");
    exit 1;
}
my $pid = $config->{$CONFIG_PID};
my $vid = $config->{$CONFIG_VID};
my $bid = Utils::check_vid($vid)->{bid};

# Instantiate project and set working directory
my $project = Project::create_project($pid);
$project->{prog_root} = $WORK_DIR;


my $current_rev = $project->lookup($vid);
my $src_dir     = $project->src_dir($vid);
my $test_dir    = $project->test_dir($vid);

# Logging and data directory
my $REVISIONS_DIR = "$WORK_DIR/.revisions";
system("mkdir -p $REVISIONS_DIR") == 0 or die "Cannot create '$REVISIONS_DIR' directory";

# Analyze generated test suites
if (defined $TEST_SUITE_ARCHIVE) {
    $TEST_SUITE_ARCHIVE =~ /^$pid-(\d+[bf])-([^\.]+)(\.(\d+))?.tar.bz2$/;
    my $archive_vid = $1;
    my $archive_test_id = $4 // 1;
    if ($vid eq $archive_vid) {
        die "VID '$vid' must match the VID in the archive ('$archive_vid')";
    }

    # Extract external test suite
    my $generated_test_dir = "$WORK_DIR/.test_suite";
    Utils::extract_test_suite($TEST_SUITE_ARCHIVE, $generated_test_dir) or die;
    _run_test_evolution_analysis($archive_test_id, $generated_test_dir);
} else {
    _run_test_evolution_analysis(1);
}

#
# Run test evolution analysis for developer-written or automatically generated
# test suites.
#
sub _run_test_evolution_analysis {
    my ($test_suite_id, $generated_test_dir) = @_;

    my $log = "";
    my $cmd;
    # TODO: Implement as subroutine in VCS modules
    if ($pid eq "Chart") {
        # 1. Jump to checkout directory
        $cmd = "cd $WORK_DIR";
        if ($FUTURE_COMMITS == 1) {
            # 2. Get all future commits
            my $next_rev = $current_rev + 1;
            $cmd .= " && a=\$(svn log -rHEAD:$next_rev $src_dir | grep '^r\\d*' | cut -f1 -d' ' | tr -d 'r')";
            $cmd .= " && b=\$(svn log -rHEAD:$next_rev $test_dir | grep '^r\\d*' | cut -f1 -d' ' | tr -d 'r')";
        } else {
            # 2. Get all past commits except the official buggy/fixed one
            my $previous_rev = $current_rev - 1;
            $cmd .= " && a=\$(svn log -r$previous_rev:1 $src_dir | grep '^r\\d*' | cut -f1 -d' ' | tr -d 'r')";
            $cmd .= " && b=\$(svn log -r$previous_rev:1 $test_dir | grep '^r\\d*' | cut -f1 -d' ' | tr -d 'r')";
        }
        $cmd .= " && echo \"\$a\\n\$b\" | sort -u -h -r";
    } else {
        # 1. Jump to checkout directory
        # 2. Get the current commit hash
        $cmd = "cd $WORK_DIR && git rev-parse HEAD";
        if ($FUTURE_COMMITS == 1) {
            # 3. Get all future commits
            $cmd .= " && git rev-list origin ^HEAD -- $src_dir -- $test_dir";
        } else {
            # 3. Get all past commits except the official buggy/fixed one
            $cmd .= " && git rev-list \$(git rev-list HEAD -- $src_dir -- $test_dir | tail -n1) $current_rev^ -- $src_dir -- $test_dir";
       }
    }
    if ($FUTURE_COMMITS == 1) {
        Utils::exec_cmd("$cmd", "Obtain future commits", \$log) or die;
    } else {
        Utils::exec_cmd("$cmd", "Obtain past commits", \$log) or die;
    }
    my @commits = split(/\n/, $log);
    my $num_commits = scalar(@commits);
    if ($pid ne "Chart") {
        $current_rev = shift @commits; # get very first commit of the list
    }

    my $runtime_data_file = "$WORK_DIR/tests_runtime.txt";

    open(CSV, ">$WORK_DIR/test_evolution.csv") or die "Cannot write output csv file $!";
    print(CSV "project_id,version_id,num_revisions,revision_id,test_name,test_runtime,test_outcome,test_stack_strace\n");

    my $commit_index = 0;
    my $number_of_consecutive_failing_commits = 0;
    foreach my $commit (@commits) {
        if ($number_of_consecutive_failing_commits == 5) {
            # There is a chance that some past/future commits do not compile due
            # to external libraries to which D4J is not aware of, or just potential
            # minor mistakes that have been committed. Instead of stopping the
            # analysis right way when the compilation of the source code fails,
            # in here the compilation is allowed to fail in X consecutive commits.
            # The motivation behind this decision is that a compilation might
            # just fail due to a mistake that has been committed. In such cases,
            # it is likely that the source code of the following commits (either
            # past/future) will compile without any issue. Once the maximum allowed
            # number of consecutive failing commits is reached, the test evolution
            # analysis is stopped.
            last;
        }

        # TODO: Implement a proper clean target in Chart.build.xml
        if ($pid eq "Chart") {
            system("rm -rf $WORK_DIR/build") == 0 or die "Fail to remove create '$WORK_DIR/build' directory";
        } else {
            $project->_ant_call("clean") || die "Fail to clean build directory";
        }

        my $src_comp_log = "$REVISIONS_DIR/$commit_index.test_evolution_analysis.src.comp.log";
        system(">$src_comp_log") == 0 or die "Fail to reset '$src_comp_log' file";
        unless ($project->compile($src_comp_log)) {
            ++$number_of_consecutive_failing_commits;
            $commit_index = _update_commit_index($commit_index);

            # go to the next revision
            _get_and_apply_diff($commit, $commit_index, $current_rev) == 0 or last;
            $current_rev = $commit;

            next;
        }

        my $test_comp_log = "$REVISIONS_DIR/$commit_index.test_evolution_analysis.test.comp.log";
        system(">$test_comp_log") == 0 or die "Fail to reset '$test_comp_log' file";
        if (defined $TEST_SUITE_ARCHIVE) {
            unless ($project->compile_ext_tests($generated_test_dir, $test_comp_log)) {
                ++$number_of_consecutive_failing_commits;
                $commit_index = _update_commit_index($commit_index);

                # go to the next revision
                _get_and_apply_diff($commit, $commit_index, $current_rev) == 0 or last;
                $current_rev = $commit;

                next;
            }
        } else {
            unless ($project->compile_tests($test_comp_log)) {
                ++$number_of_consecutive_failing_commits;
                $commit_index = _update_commit_index($commit_index);

                # go to the next revision
                _get_and_apply_diff($commit, $commit_index, $current_rev) == 0 or last;
                $current_rev = $commit;

                next;
            }
        }

        my $test_log = "$REVISIONS_DIR/$commit_index.test_evolution_analysis.test.run.log";
        system(">$test_log") == 0 or die "Fail to reset '$test_log' file";
        system(">$runtime_data_file") == 0 or die "Fail to reset '$runtime_data_file' file";
        if (defined $TEST_SUITE_ARCHIVE) {
            $project->run_ext_tests($generated_test_dir, "*.java", $test_log) or die "Cannot run generated tests";
        } elsif ($REL_TESTS == 1) {
            $project->run_relevant_tests($test_log) or die "Cannot run all relevant developer-written tests";
        } else {
            $project->run_tests($test_log) or die "Cannot run all developer-written tests";
        }

        open(DATA, $runtime_data_file);
        while (<DATA>) {
            print(CSV "$pid,$vid,$num_commits,$commit_index,$_");
        }
        close(DATA);

        # either increment or decrement the commit index
        $commit_index = _update_commit_index($commit_index);
        # extract next diff and apply it
        _get_and_apply_diff($commit, $commit_index, $current_rev) == 0 or last;

        $current_rev = $commit;
        $number_of_consecutive_failing_commits = 0; # reset counter
    }

    close(CSV);
}

#
# Update the index of the current commit.
#
sub _update_commit_index {
    my ($index) = @_;
    if ($FUTURE_COMMITS == 1) {
        return ++$index;
    } else {
        return --$index;
    }
}

#
# Extract the diff between two revisions and apply it.
#
sub _get_and_apply_diff {
    my ($commit, $commit_index, $current_rev) = @_;

    my $tmp_diff = "$REVISIONS_DIR/$commit_index.diff";
    system(">$tmp_diff") == 0 or die "Fail to reset '$tmp_diff' file";
    # In here we use a custom made command, as the official one, i.e.,
    #   $project->export_diff($current_rev, $commit, $tmp_diff) or die "Cannot export diff";
    # used the official repository released with D4J rather than the current working directory
    if ($pid eq "Chart") {
        if ($commit_index == -1 or $commit_index == 1) {
            my $cmd = "cd $WORK_DIR && git checkout -q \$(git log --reverse --pretty=oneline | grep \"D4J_\"$pid\"_\"$bid\"_POST_FIX_\" | tail -n1 | cut -f1 -d' ') $src_dir $test_dir && svn update --accept theirs-full -r$current_rev";
            my $log = "";
            Utils::exec_cmd("$cmd", "Revert SVN repository to revision $current_rev", \$log) or die;
        }
        system("cd $WORK_DIR && svn diff -r$current_rev:$commit > $tmp_diff") == 0 or die "Cannot export diff";
    } else {
        system("cd $WORK_DIR && git diff --no-ext-diff --binary $current_rev $commit -- $src_dir -- $test_dir > $tmp_diff") == 0 or die "Cannot export diff";
    }
    if (!-z $tmp_diff) {
        unless ($project->apply_patch($WORK_DIR, $tmp_diff)) {
            return 1;
        }
    }

    return 0;
}

1;
